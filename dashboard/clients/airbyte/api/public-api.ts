/* tslint:disable */
/* eslint-disable */
/**
 * airbyte-api
 * Programatically control Airbyte Cloud, OSS & Enterprise.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ConnectionCreateRequest } from '../model';
// @ts-ignore
import type { ConnectionPatchRequest } from '../model';
// @ts-ignore
import type { ConnectionResponse } from '../model';
// @ts-ignore
import type { ConnectionsResponse } from '../model';
// @ts-ignore
import type { DestinationCreateRequest } from '../model';
// @ts-ignore
import type { DestinationPatchRequest } from '../model';
// @ts-ignore
import type { DestinationPutRequest } from '../model';
// @ts-ignore
import type { DestinationResponse } from '../model';
// @ts-ignore
import type { DestinationsResponse } from '../model';
// @ts-ignore
import type { InitiateOauthRequest } from '../model';
// @ts-ignore
import type { JobCreateRequest } from '../model';
// @ts-ignore
import type { JobResponse } from '../model';
// @ts-ignore
import type { JobStatusEnum } from '../model';
// @ts-ignore
import type { JobTypeEnum } from '../model';
// @ts-ignore
import type { JobsResponse } from '../model';
// @ts-ignore
import type { OrganizationsResponse } from '../model';
// @ts-ignore
import type { PermissionCreateRequest } from '../model';
// @ts-ignore
import type { PermissionResponse } from '../model';
// @ts-ignore
import type { PermissionUpdateRequest } from '../model';
// @ts-ignore
import type { PermissionsResponse } from '../model';
// @ts-ignore
import type { SourceCreateRequest } from '../model';
// @ts-ignore
import type { SourcePatchRequest } from '../model';
// @ts-ignore
import type { SourcePutRequest } from '../model';
// @ts-ignore
import type { SourceResponse } from '../model';
// @ts-ignore
import type { SourcesResponse } from '../model';
// @ts-ignore
import type { StreamProperties } from '../model';
// @ts-ignore
import type { UsersResponse } from '../model';
// @ts-ignore
import type { WorkspaceCreateRequest } from '../model';
// @ts-ignore
import type { WorkspaceOAuthCredentialsRequest } from '../model';
// @ts-ignore
import type { WorkspaceResponse } from '../model';
// @ts-ignore
import type { WorkspaceUpdateRequest } from '../model';
// @ts-ignore
import type { WorkspacesResponse } from '../model';
/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a running Job
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJob: async (jobId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cancelJob', 'jobId', jobId)
            const localVarPath = `/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a connection
         * @param {ConnectionCreateRequest} connectionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (connectionCreateRequest: ConnectionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionCreateRequest' is not null or undefined
            assertParamExists('createConnection', 'connectionCreateRequest', connectionCreateRequest)
            const localVarPath = `/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a destination given a name, workspace id, and a json blob containing the configuration for the source.
         * @summary Create a destination
         * @param {DestinationCreateRequest} [destinationCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDestination: async (destinationCreateRequest?: DestinationCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/destinations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a sync or reset job of a connection
         * @param {JobCreateRequest} jobCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob: async (jobCreateRequest: JobCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobCreateRequest' is not null or undefined
            assertParamExists('createJob', 'jobCreateRequest', jobCreateRequest)
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create/update a set of OAuth credentials to override the Airbyte-provided OAuth credentials used for source/destination OAuth. In order to determine what the credential configuration needs to be, please see the connector specification of the relevant source/destination.
         * @summary Create OAuth override credentials for a workspace and source type.
         * @param {string} workspaceId 
         * @param {WorkspaceOAuthCredentialsRequest} workspaceOAuthCredentialsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateWorkspaceOAuthCredentials: async (workspaceId: string, workspaceOAuthCredentialsRequest: WorkspaceOAuthCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createOrUpdateWorkspaceOAuthCredentials', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceOAuthCredentialsRequest' is not null or undefined
            assertParamExists('createOrUpdateWorkspaceOAuthCredentials', 'workspaceOAuthCredentialsRequest', workspaceOAuthCredentialsRequest)
            const localVarPath = `/workspaces/{workspaceId}/oauthCredentials`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceOAuthCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a permission
         * @param {PermissionCreateRequest} permissionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermission: async (permissionCreateRequest: PermissionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionCreateRequest' is not null or undefined
            assertParamExists('createPermission', 'permissionCreateRequest', permissionCreateRequest)
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
         * @summary Create a source
         * @param {SourceCreateRequest} [sourceCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (sourceCreateRequest?: SourceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a workspace
         * @param {WorkspaceCreateRequest} workspaceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (workspaceCreateRequest: WorkspaceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceCreateRequest' is not null or undefined
            assertParamExists('createWorkspace', 'workspaceCreateRequest', workspaceCreateRequest)
            const localVarPath = `/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection: async (connectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('deleteConnection', 'connectionId', connectionId)
            const localVarPath = `/connections/{connectionId}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Destination
         * @param {string} destinationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination: async (destinationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationId' is not null or undefined
            assertParamExists('deleteDestination', 'destinationId', destinationId)
            const localVarPath = `/destinations/{destinationId}`
                .replace(`{${"destinationId"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Permission
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission: async (permissionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('deletePermission', 'permissionId', permissionId)
            const localVarPath = `/permissions/{permissionId}`
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Source
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (sourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSource', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Connection details
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection: async (connectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getConnection', 'connectionId', connectionId)
            const localVarPath = `/connections/{connectionId}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Destination details
         * @param {string} destinationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination: async (destinationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationId' is not null or undefined
            assertParamExists('getDestination', 'destinationId', destinationId)
            const localVarPath = `/destinations/{destinationId}`
                .replace(`{${"destinationId"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Job status and details
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (jobId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJob', 'jobId', jobId)
            const localVarPath = `/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Permission details
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission: async (permissionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('getPermission', 'permissionId', permissionId)
            const localVarPath = `/permissions/{permissionId}`
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Source details
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (sourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSource', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get stream properties
         * @param {string} sourceId ID of the source
         * @param {string} [destinationId] ID of the destination
         * @param {boolean} [ignoreCache] If true pull the latest schema from the source, else pull from cache (default false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamProperties: async (sourceId: string, destinationId?: string, ignoreCache?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getStreamProperties', 'sourceId', sourceId)
            const localVarPath = `/streams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (destinationId !== undefined) {
                localVarQueryParameter['destinationId'] = destinationId;
            }

            if (ignoreCache !== undefined) {
                localVarQueryParameter['ignoreCache'] = ignoreCache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Workspace details
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.  This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.  That secret ID can be used to create a source with credentials in place of actual tokens.
         * @summary Initiate OAuth for a source
         * @param {InitiateOauthRequest} initiateOauthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateOAuth: async (initiateOauthRequest: InitiateOauthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiateOauthRequest' is not null or undefined
            assertParamExists('initiateOAuth', 'initiateOauthRequest', initiateOauthRequest)
            const localVarPath = `/sources/initiateOAuth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateOauthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List connections
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list connections for. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted connections in the returned results.
         * @param {number} [limit] Set the limit on the number of Connections returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning Connections. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections: async (workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceIds) {
                localVarQueryParameter['workspaceIds'] = workspaceIds;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['includeDeleted'] = includeDeleted;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List destinations
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list destinations for. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted destinations in the returned results.
         * @param {number} [limit] Set the limit on the number of destinations returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning destinations. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDestinations: async (workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/destinations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceIds) {
                localVarQueryParameter['workspaceIds'] = workspaceIds;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['includeDeleted'] = includeDeleted;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Jobs by sync type
         * @param {string} [connectionId] Filter the Jobs by connectionId.
         * @param {number} [limit] Set the limit on the number of Jobs returned. The default is 20 Jobs.
         * @param {number} [offset] Set the offset to start at when returning Jobs. The default is 0.
         * @param {JobTypeEnum} [jobType] Filter the Jobs by jobType.
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list jobs for. Empty list will retrieve all allowed workspaces.
         * @param {JobStatusEnum} [status] The Job status you want to filter by
         * @param {string} [createdAtStart] The start date to filter by
         * @param {string} [createdAtEnd] The end date to filter by
         * @param {string} [updatedAtStart] The start date to filter by
         * @param {string} [updatedAtEnd] The end date to filter by
         * @param {string} [orderBy] The field and method to use for ordering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (connectionId?: string, limit?: number, offset?: number, jobType?: JobTypeEnum, workspaceIds?: Array<string>, status?: JobStatusEnum, createdAtStart?: string, createdAtEnd?: string, updatedAtStart?: string, updatedAtEnd?: string, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (connectionId !== undefined) {
                localVarQueryParameter['connectionId'] = connectionId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (jobType !== undefined) {
                localVarQueryParameter['jobType'] = jobType;
            }

            if (workspaceIds) {
                localVarQueryParameter['workspaceIds'] = workspaceIds;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (updatedAtStart !== undefined) {
                localVarQueryParameter['updatedAtStart'] = (updatedAtStart as any instanceof Date) ?
                    (updatedAtStart as any).toISOString() :
                    updatedAtStart;
            }

            if (updatedAtEnd !== undefined) {
                localVarQueryParameter['updatedAtEnd'] = (updatedAtEnd as any instanceof Date) ?
                    (updatedAtEnd as any).toISOString() :
                    updatedAtEnd;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists users organizations.
         * @summary List all organizations for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationsForUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Permissions by user id
         * @param {string} [userId] User Id in permission.
         * @param {string} [organizationId] This is required if you want to read someone else\&#39;s permissions, and you should have organization admin or a higher role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions: async (userId?: string, organizationId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List sources
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list sources for. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted sources in the returned results.
         * @param {number} [limit] Set the limit on the number of sources returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning sources. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceIds) {
                localVarQueryParameter['workspaceIds'] = workspaceIds;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['includeDeleted'] = includeDeleted;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Organization Admin user can list all users within the same organization. Also provide filtering on a list of user IDs or/and a list of user emails.
         * @summary List all users within an organization
         * @param {string} organizationId 
         * @param {Array<string>} [ids] List of user IDs to filter by
         * @param {Array<string>} [emails] List of user emails to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersWithinAnOrganization: async (organizationId: string, ids?: Array<string>, emails?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listUsersWithinAnOrganization', 'organizationId', organizationId)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (emails) {
                localVarQueryParameter['emails'] = emails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List workspaces
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to fetch. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted workspaces in the returned results.
         * @param {number} [limit] Set the limit on the number of workspaces returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning workspaces. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces: async (workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceIds) {
                localVarQueryParameter['workspaceIds'] = workspaceIds;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['includeDeleted'] = includeDeleted;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Connection details
         * @param {string} connectionId 
         * @param {ConnectionPatchRequest} connectionPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnection: async (connectionId: string, connectionPatchRequest: ConnectionPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('patchConnection', 'connectionId', connectionId)
            // verify required parameter 'connectionPatchRequest' is not null or undefined
            assertParamExists('patchConnection', 'connectionPatchRequest', connectionPatchRequest)
            const localVarPath = `/connections/{connectionId}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Destination
         * @param {string} destinationId 
         * @param {DestinationPatchRequest} [destinationPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDestination: async (destinationId: string, destinationPatchRequest?: DestinationPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationId' is not null or undefined
            assertParamExists('patchDestination', 'destinationId', destinationId)
            const localVarPath = `/destinations/{destinationId}`
                .replace(`{${"destinationId"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Source
         * @param {string} sourceId 
         * @param {SourcePatchRequest} [sourcePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSource: async (sourceId: string, sourcePatchRequest?: SourcePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchSource', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourcePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Destination and fully overwrite it
         * @param {string} destinationId 
         * @param {DestinationPutRequest} [destinationPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDestination: async (destinationId: string, destinationPutRequest?: DestinationPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destinationId' is not null or undefined
            assertParamExists('putDestination', 'destinationId', destinationId)
            const localVarPath = `/destinations/{destinationId}`
                .replace(`{${"destinationId"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Source and fully overwrite it
         * @param {string} sourceId 
         * @param {SourcePutRequest} [sourcePutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSource: async (sourceId: string, sourcePutRequest?: SourcePutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putSource', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourcePutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a permission
         * @param {string} permissionId 
         * @param {PermissionUpdateRequest} permissionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission: async (permissionId: string, permissionUpdateRequest: PermissionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('updatePermission', 'permissionId', permissionId)
            // verify required parameter 'permissionUpdateRequest' is not null or undefined
            assertParamExists('updatePermission', 'permissionUpdateRequest', permissionUpdateRequest)
            const localVarPath = `/permissions/{permissionId}`
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} workspaceId 
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceUpdateRequest', workspaceUpdateRequest)
            const localVarPath = `/workspaces/{workspaceId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel a running Job
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelJob(jobId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.cancelJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a connection
         * @param {ConnectionCreateRequest} connectionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(connectionCreateRequest: ConnectionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnection(connectionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.createConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a destination given a name, workspace id, and a json blob containing the configuration for the source.
         * @summary Create a destination
         * @param {DestinationCreateRequest} [destinationCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDestination(destinationCreateRequest?: DestinationCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDestination(destinationCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.createDestination']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Trigger a sync or reset job of a connection
         * @param {JobCreateRequest} jobCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJob(jobCreateRequest: JobCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJob(jobCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.createJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create/update a set of OAuth credentials to override the Airbyte-provided OAuth credentials used for source/destination OAuth. In order to determine what the credential configuration needs to be, please see the connector specification of the relevant source/destination.
         * @summary Create OAuth override credentials for a workspace and source type.
         * @param {string} workspaceId 
         * @param {WorkspaceOAuthCredentialsRequest} workspaceOAuthCredentialsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateWorkspaceOAuthCredentials(workspaceId: string, workspaceOAuthCredentialsRequest: WorkspaceOAuthCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateWorkspaceOAuthCredentials(workspaceId, workspaceOAuthCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.createOrUpdateWorkspaceOAuthCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a permission
         * @param {PermissionCreateRequest} permissionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPermission(permissionCreateRequest: PermissionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPermission(permissionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.createPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
         * @summary Create a source
         * @param {SourceCreateRequest} [sourceCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(sourceCreateRequest?: SourceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(sourceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.createSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a workspace
         * @param {WorkspaceCreateRequest} workspaceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(workspaceCreateRequest: WorkspaceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(workspaceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.createWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Connection
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnection(connectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnection(connectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.deleteConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Destination
         * @param {string} destinationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDestination(destinationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDestination(destinationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.deleteDestination']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Permission
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermission(permissionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermission(permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.deletePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Source
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(sourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.deleteSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.deleteWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Connection details
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnection(connectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnection(connectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.getConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Destination details
         * @param {string} destinationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestination(destinationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestination(destinationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.getDestination']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.getHealthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Job status and details
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(jobId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.getJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Permission details
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermission(permissionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermission(permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.getPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Source details
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(sourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.getSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get stream properties
         * @param {string} sourceId ID of the source
         * @param {string} [destinationId] ID of the destination
         * @param {boolean} [ignoreCache] If true pull the latest schema from the source, else pull from cache (default false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamProperties(sourceId: string, destinationId?: string, ignoreCache?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StreamProperties>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamProperties(sourceId, destinationId, ignoreCache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.getStreamProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Workspace details
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspace(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspace(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.getWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.  This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.  That secret ID can be used to create a source with credentials in place of actual tokens.
         * @summary Initiate OAuth for a source
         * @param {InitiateOauthRequest} initiateOauthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateOAuth(initiateOauthRequest: InitiateOauthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateOAuth(initiateOauthRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.initiateOAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List connections
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list connections for. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted connections in the returned results.
         * @param {number} [limit] Set the limit on the number of Connections returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning Connections. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnections(workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnections(workspaceIds, includeDeleted, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.listConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List destinations
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list destinations for. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted destinations in the returned results.
         * @param {number} [limit] Set the limit on the number of destinations returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning destinations. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDestinations(workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDestinations(workspaceIds, includeDeleted, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.listDestinations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Jobs by sync type
         * @param {string} [connectionId] Filter the Jobs by connectionId.
         * @param {number} [limit] Set the limit on the number of Jobs returned. The default is 20 Jobs.
         * @param {number} [offset] Set the offset to start at when returning Jobs. The default is 0.
         * @param {JobTypeEnum} [jobType] Filter the Jobs by jobType.
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list jobs for. Empty list will retrieve all allowed workspaces.
         * @param {JobStatusEnum} [status] The Job status you want to filter by
         * @param {string} [createdAtStart] The start date to filter by
         * @param {string} [createdAtEnd] The end date to filter by
         * @param {string} [updatedAtStart] The start date to filter by
         * @param {string} [updatedAtEnd] The end date to filter by
         * @param {string} [orderBy] The field and method to use for ordering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(connectionId?: string, limit?: number, offset?: number, jobType?: JobTypeEnum, workspaceIds?: Array<string>, status?: JobStatusEnum, createdAtStart?: string, createdAtEnd?: string, updatedAtStart?: string, updatedAtEnd?: string, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(connectionId, limit, offset, jobType, workspaceIds, status, createdAtStart, createdAtEnd, updatedAtStart, updatedAtEnd, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.listJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists users organizations.
         * @summary List all organizations for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationsForUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationsForUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.listOrganizationsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Permissions by user id
         * @param {string} [userId] User Id in permission.
         * @param {string} [organizationId] This is required if you want to read someone else\&#39;s permissions, and you should have organization admin or a higher role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissions(userId?: string, organizationId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissions(userId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.listPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List sources
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list sources for. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted sources in the returned results.
         * @param {number} [limit] Set the limit on the number of sources returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning sources. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourcesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSources(workspaceIds, includeDeleted, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.listSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Organization Admin user can list all users within the same organization. Also provide filtering on a list of user IDs or/and a list of user emails.
         * @summary List all users within an organization
         * @param {string} organizationId 
         * @param {Array<string>} [ids] List of user IDs to filter by
         * @param {Array<string>} [emails] List of user emails to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersWithinAnOrganization(organizationId: string, ids?: Array<string>, emails?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersWithinAnOrganization(organizationId, ids, emails, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.listUsersWithinAnOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List workspaces
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to fetch. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted workspaces in the returned results.
         * @param {number} [limit] Set the limit on the number of workspaces returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning workspaces. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaces(workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaces(workspaceIds, includeDeleted, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.listWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Connection details
         * @param {string} connectionId 
         * @param {ConnectionPatchRequest} connectionPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchConnection(connectionId: string, connectionPatchRequest: ConnectionPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchConnection(connectionId, connectionPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.patchConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Destination
         * @param {string} destinationId 
         * @param {DestinationPatchRequest} [destinationPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchDestination(destinationId: string, destinationPatchRequest?: DestinationPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchDestination(destinationId, destinationPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.patchDestination']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Source
         * @param {string} sourceId 
         * @param {SourcePatchRequest} [sourcePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchSource(sourceId: string, sourcePatchRequest?: SourcePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSource(sourceId, sourcePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.patchSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Destination and fully overwrite it
         * @param {string} destinationId 
         * @param {DestinationPutRequest} [destinationPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDestination(destinationId: string, destinationPutRequest?: DestinationPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestinationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDestination(destinationId, destinationPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.putDestination']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Source and fully overwrite it
         * @param {string} sourceId 
         * @param {SourcePutRequest} [sourcePutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSource(sourceId: string, sourcePutRequest?: SourcePutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSource(sourceId, sourcePutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.putSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a permission
         * @param {string} permissionId 
         * @param {PermissionUpdateRequest} permissionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermission(permissionId: string, permissionUpdateRequest: PermissionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermission(permissionId, permissionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.updatePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} workspaceId 
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(workspaceId, workspaceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.updateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel a running Job
         * @param {PublicApiCancelJob0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJob(requestParameters: PublicApiCancelJob0Request, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.cancelJob(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a connection
         * @param {PublicApiCreateConnection0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(requestParameters: PublicApiCreateConnection0Request, options?: RawAxiosRequestConfig): AxiosPromise<ConnectionResponse> {
            return localVarFp.createConnection(requestParameters.connectionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a destination given a name, workspace id, and a json blob containing the configuration for the source.
         * @summary Create a destination
         * @param {PublicApiCreateDestination0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDestination(requestParameters: PublicApiCreateDestination0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<DestinationResponse> {
            return localVarFp.createDestination(requestParameters.destinationCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a sync or reset job of a connection
         * @param {PublicApiCreateJob0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(requestParameters: PublicApiCreateJob0Request, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.createJob(requestParameters.jobCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create/update a set of OAuth credentials to override the Airbyte-provided OAuth credentials used for source/destination OAuth. In order to determine what the credential configuration needs to be, please see the connector specification of the relevant source/destination.
         * @summary Create OAuth override credentials for a workspace and source type.
         * @param {PublicApiCreateOrUpdateWorkspaceOAuthCredentials0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateWorkspaceOAuthCredentials(requestParameters: PublicApiCreateOrUpdateWorkspaceOAuthCredentials0Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createOrUpdateWorkspaceOAuthCredentials(requestParameters.workspaceId, requestParameters.workspaceOAuthCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a permission
         * @param {PublicApiCreatePermission0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermission(requestParameters: PublicApiCreatePermission0Request, options?: RawAxiosRequestConfig): AxiosPromise<PermissionResponse> {
            return localVarFp.createPermission(requestParameters.permissionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
         * @summary Create a source
         * @param {PublicApiCreateSource0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(requestParameters: PublicApiCreateSource0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<SourceResponse> {
            return localVarFp.createSource(requestParameters.sourceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a workspace
         * @param {PublicApiCreateWorkspace0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(requestParameters: PublicApiCreateWorkspace0Request, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse> {
            return localVarFp.createWorkspace(requestParameters.workspaceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Connection
         * @param {PublicApiDeleteConnection0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(requestParameters: PublicApiDeleteConnection0Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteConnection(requestParameters.connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Destination
         * @param {PublicApiDeleteDestination0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination(requestParameters: PublicApiDeleteDestination0Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDestination(requestParameters.destinationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Permission
         * @param {PublicApiDeletePermission0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission(requestParameters: PublicApiDeletePermission0Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePermission(requestParameters.permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Source
         * @param {PublicApiDeleteSource0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(requestParameters: PublicApiDeleteSource0Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSource(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Workspace
         * @param {PublicApiDeleteWorkspace0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(requestParameters: PublicApiDeleteWorkspace0Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Connection details
         * @param {PublicApiGetConnection0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(requestParameters: PublicApiGetConnection0Request, options?: RawAxiosRequestConfig): AxiosPromise<ConnectionResponse> {
            return localVarFp.getConnection(requestParameters.connectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Destination details
         * @param {PublicApiGetDestination0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination(requestParameters: PublicApiGetDestination0Request, options?: RawAxiosRequestConfig): AxiosPromise<DestinationResponse> {
            return localVarFp.getDestination(requestParameters.destinationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getHealthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Job status and details
         * @param {PublicApiGetJob0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(requestParameters: PublicApiGetJob0Request, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.getJob(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Permission details
         * @param {PublicApiGetPermission0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission(requestParameters: PublicApiGetPermission0Request, options?: RawAxiosRequestConfig): AxiosPromise<PermissionResponse> {
            return localVarFp.getPermission(requestParameters.permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Source details
         * @param {PublicApiGetSource0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(requestParameters: PublicApiGetSource0Request, options?: RawAxiosRequestConfig): AxiosPromise<SourceResponse> {
            return localVarFp.getSource(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get stream properties
         * @param {PublicApiGetStreamProperties0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamProperties(requestParameters: PublicApiGetStreamProperties0Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<StreamProperties>> {
            return localVarFp.getStreamProperties(requestParameters.sourceId, requestParameters.destinationId, requestParameters.ignoreCache, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Workspace details
         * @param {PublicApiGetWorkspace0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(requestParameters: PublicApiGetWorkspace0Request, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse> {
            return localVarFp.getWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.  This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.  That secret ID can be used to create a source with credentials in place of actual tokens.
         * @summary Initiate OAuth for a source
         * @param {PublicApiInitiateOAuth0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateOAuth(requestParameters: PublicApiInitiateOAuth0Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.initiateOAuth(requestParameters.initiateOauthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List connections
         * @param {PublicApiListConnections0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(requestParameters: PublicApiListConnections0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<ConnectionsResponse> {
            return localVarFp.listConnections(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List destinations
         * @param {PublicApiListDestinations0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDestinations(requestParameters: PublicApiListDestinations0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<DestinationsResponse> {
            return localVarFp.listDestinations(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Jobs by sync type
         * @param {PublicApiListJobs0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(requestParameters: PublicApiListJobs0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<JobsResponse> {
            return localVarFp.listJobs(requestParameters.connectionId, requestParameters.limit, requestParameters.offset, requestParameters.jobType, requestParameters.workspaceIds, requestParameters.status, requestParameters.createdAtStart, requestParameters.createdAtEnd, requestParameters.updatedAtStart, requestParameters.updatedAtEnd, requestParameters.orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists users organizations.
         * @summary List all organizations for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationsForUser(options?: RawAxiosRequestConfig): AxiosPromise<OrganizationsResponse> {
            return localVarFp.listOrganizationsForUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Permissions by user id
         * @param {PublicApiListPermissions0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(requestParameters: PublicApiListPermissions0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<PermissionsResponse> {
            return localVarFp.listPermissions(requestParameters.userId, requestParameters.organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List sources
         * @param {PublicApiListSources0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(requestParameters: PublicApiListSources0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<SourcesResponse> {
            return localVarFp.listSources(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Organization Admin user can list all users within the same organization. Also provide filtering on a list of user IDs or/and a list of user emails.
         * @summary List all users within an organization
         * @param {PublicApiListUsersWithinAnOrganization0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersWithinAnOrganization(requestParameters: PublicApiListUsersWithinAnOrganization0Request, options?: RawAxiosRequestConfig): AxiosPromise<UsersResponse> {
            return localVarFp.listUsersWithinAnOrganization(requestParameters.organizationId, requestParameters.ids, requestParameters.emails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List workspaces
         * @param {PublicApiListWorkspaces0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(requestParameters: PublicApiListWorkspaces0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<WorkspacesResponse> {
            return localVarFp.listWorkspaces(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Connection details
         * @param {PublicApiPatchConnection0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnection(requestParameters: PublicApiPatchConnection0Request, options?: RawAxiosRequestConfig): AxiosPromise<ConnectionResponse> {
            return localVarFp.patchConnection(requestParameters.connectionId, requestParameters.connectionPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Destination
         * @param {PublicApiPatchDestination0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDestination(requestParameters: PublicApiPatchDestination0Request, options?: RawAxiosRequestConfig): AxiosPromise<DestinationResponse> {
            return localVarFp.patchDestination(requestParameters.destinationId, requestParameters.destinationPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Source
         * @param {PublicApiPatchSource0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSource(requestParameters: PublicApiPatchSource0Request, options?: RawAxiosRequestConfig): AxiosPromise<SourceResponse> {
            return localVarFp.patchSource(requestParameters.sourceId, requestParameters.sourcePatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Destination and fully overwrite it
         * @param {PublicApiPutDestination0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDestination(requestParameters: PublicApiPutDestination0Request, options?: RawAxiosRequestConfig): AxiosPromise<DestinationResponse> {
            return localVarFp.putDestination(requestParameters.destinationId, requestParameters.destinationPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Source and fully overwrite it
         * @param {PublicApiPutSource0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSource(requestParameters: PublicApiPutSource0Request, options?: RawAxiosRequestConfig): AxiosPromise<SourceResponse> {
            return localVarFp.putSource(requestParameters.sourceId, requestParameters.sourcePutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a permission
         * @param {PublicApiUpdatePermission0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission(requestParameters: PublicApiUpdatePermission0Request, options?: RawAxiosRequestConfig): AxiosPromise<PermissionResponse> {
            return localVarFp.updatePermission(requestParameters.permissionId, requestParameters.permissionUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace
         * @param {PublicApiUpdateWorkspace0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(requestParameters: PublicApiUpdateWorkspace0Request, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse> {
            return localVarFp.updateWorkspace(requestParameters.workspaceId, requestParameters.workspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelJob operation in PublicApi.
 * @export
 * @interface PublicApiCancelJob0Request
 */
export interface PublicApiCancelJob0Request {
    /**
     * 
     * @type {number}
     * @memberof PublicApiCancelJob0
     */
    readonly jobId: number
}

/**
 * Request parameters for createConnection operation in PublicApi.
 * @export
 * @interface PublicApiCreateConnection0Request
 */
export interface PublicApiCreateConnection0Request {
    /**
     * 
     * @type {ConnectionCreateRequest}
     * @memberof PublicApiCreateConnection0
     */
    readonly connectionCreateRequest: ConnectionCreateRequest
}

/**
 * Request parameters for createDestination operation in PublicApi.
 * @export
 * @interface PublicApiCreateDestination0Request
 */
export interface PublicApiCreateDestination0Request {
    /**
     * 
     * @type {DestinationCreateRequest}
     * @memberof PublicApiCreateDestination0
     */
    readonly destinationCreateRequest?: DestinationCreateRequest
}

/**
 * Request parameters for createJob operation in PublicApi.
 * @export
 * @interface PublicApiCreateJob0Request
 */
export interface PublicApiCreateJob0Request {
    /**
     * 
     * @type {JobCreateRequest}
     * @memberof PublicApiCreateJob0
     */
    readonly jobCreateRequest: JobCreateRequest
}

/**
 * Request parameters for createOrUpdateWorkspaceOAuthCredentials operation in PublicApi.
 * @export
 * @interface PublicApiCreateOrUpdateWorkspaceOAuthCredentials0Request
 */
export interface PublicApiCreateOrUpdateWorkspaceOAuthCredentials0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiCreateOrUpdateWorkspaceOAuthCredentials0
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceOAuthCredentialsRequest}
     * @memberof PublicApiCreateOrUpdateWorkspaceOAuthCredentials0
     */
    readonly workspaceOAuthCredentialsRequest: WorkspaceOAuthCredentialsRequest
}

/**
 * Request parameters for createPermission operation in PublicApi.
 * @export
 * @interface PublicApiCreatePermission0Request
 */
export interface PublicApiCreatePermission0Request {
    /**
     * 
     * @type {PermissionCreateRequest}
     * @memberof PublicApiCreatePermission0
     */
    readonly permissionCreateRequest: PermissionCreateRequest
}

/**
 * Request parameters for createSource operation in PublicApi.
 * @export
 * @interface PublicApiCreateSource0Request
 */
export interface PublicApiCreateSource0Request {
    /**
     * 
     * @type {SourceCreateRequest}
     * @memberof PublicApiCreateSource0
     */
    readonly sourceCreateRequest?: SourceCreateRequest
}

/**
 * Request parameters for createWorkspace operation in PublicApi.
 * @export
 * @interface PublicApiCreateWorkspace0Request
 */
export interface PublicApiCreateWorkspace0Request {
    /**
     * 
     * @type {WorkspaceCreateRequest}
     * @memberof PublicApiCreateWorkspace0
     */
    readonly workspaceCreateRequest: WorkspaceCreateRequest
}

/**
 * Request parameters for deleteConnection operation in PublicApi.
 * @export
 * @interface PublicApiDeleteConnection0Request
 */
export interface PublicApiDeleteConnection0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiDeleteConnection0
     */
    readonly connectionId: string
}

/**
 * Request parameters for deleteDestination operation in PublicApi.
 * @export
 * @interface PublicApiDeleteDestination0Request
 */
export interface PublicApiDeleteDestination0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiDeleteDestination0
     */
    readonly destinationId: string
}

/**
 * Request parameters for deletePermission operation in PublicApi.
 * @export
 * @interface PublicApiDeletePermission0Request
 */
export interface PublicApiDeletePermission0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiDeletePermission0
     */
    readonly permissionId: string
}

/**
 * Request parameters for deleteSource operation in PublicApi.
 * @export
 * @interface PublicApiDeleteSource0Request
 */
export interface PublicApiDeleteSource0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiDeleteSource0
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteWorkspace operation in PublicApi.
 * @export
 * @interface PublicApiDeleteWorkspace0Request
 */
export interface PublicApiDeleteWorkspace0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiDeleteWorkspace0
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getConnection operation in PublicApi.
 * @export
 * @interface PublicApiGetConnection0Request
 */
export interface PublicApiGetConnection0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiGetConnection0
     */
    readonly connectionId: string
}

/**
 * Request parameters for getDestination operation in PublicApi.
 * @export
 * @interface PublicApiGetDestination0Request
 */
export interface PublicApiGetDestination0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiGetDestination0
     */
    readonly destinationId: string
}

/**
 * Request parameters for getJob operation in PublicApi.
 * @export
 * @interface PublicApiGetJob0Request
 */
export interface PublicApiGetJob0Request {
    /**
     * 
     * @type {number}
     * @memberof PublicApiGetJob0
     */
    readonly jobId: number
}

/**
 * Request parameters for getPermission operation in PublicApi.
 * @export
 * @interface PublicApiGetPermission0Request
 */
export interface PublicApiGetPermission0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiGetPermission0
     */
    readonly permissionId: string
}

/**
 * Request parameters for getSource operation in PublicApi.
 * @export
 * @interface PublicApiGetSource0Request
 */
export interface PublicApiGetSource0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiGetSource0
     */
    readonly sourceId: string
}

/**
 * Request parameters for getStreamProperties operation in PublicApi.
 * @export
 * @interface PublicApiGetStreamProperties0Request
 */
export interface PublicApiGetStreamProperties0Request {
    /**
     * ID of the source
     * @type {string}
     * @memberof PublicApiGetStreamProperties0
     */
    readonly sourceId: string

    /**
     * ID of the destination
     * @type {string}
     * @memberof PublicApiGetStreamProperties0
     */
    readonly destinationId?: string

    /**
     * If true pull the latest schema from the source, else pull from cache (default false)
     * @type {boolean}
     * @memberof PublicApiGetStreamProperties0
     */
    readonly ignoreCache?: boolean
}

/**
 * Request parameters for getWorkspace operation in PublicApi.
 * @export
 * @interface PublicApiGetWorkspace0Request
 */
export interface PublicApiGetWorkspace0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiGetWorkspace0
     */
    readonly workspaceId: string
}

/**
 * Request parameters for initiateOAuth operation in PublicApi.
 * @export
 * @interface PublicApiInitiateOAuth0Request
 */
export interface PublicApiInitiateOAuth0Request {
    /**
     * 
     * @type {InitiateOauthRequest}
     * @memberof PublicApiInitiateOAuth0
     */
    readonly initiateOauthRequest: InitiateOauthRequest
}

/**
 * Request parameters for listConnections operation in PublicApi.
 * @export
 * @interface PublicApiListConnections0Request
 */
export interface PublicApiListConnections0Request {
    /**
     * The UUIDs of the workspaces you wish to list connections for. Empty list will retrieve all allowed workspaces.
     * @type {Array<string>}
     * @memberof PublicApiListConnections0
     */
    readonly workspaceIds?: Array<string>

    /**
     * Include deleted connections in the returned results.
     * @type {boolean}
     * @memberof PublicApiListConnections0
     */
    readonly includeDeleted?: boolean

    /**
     * Set the limit on the number of Connections returned. The default is 20.
     * @type {number}
     * @memberof PublicApiListConnections0
     */
    readonly limit?: number

    /**
     * Set the offset to start at when returning Connections. The default is 0
     * @type {number}
     * @memberof PublicApiListConnections0
     */
    readonly offset?: number
}

/**
 * Request parameters for listDestinations operation in PublicApi.
 * @export
 * @interface PublicApiListDestinations0Request
 */
export interface PublicApiListDestinations0Request {
    /**
     * The UUIDs of the workspaces you wish to list destinations for. Empty list will retrieve all allowed workspaces.
     * @type {Array<string>}
     * @memberof PublicApiListDestinations0
     */
    readonly workspaceIds?: Array<string>

    /**
     * Include deleted destinations in the returned results.
     * @type {boolean}
     * @memberof PublicApiListDestinations0
     */
    readonly includeDeleted?: boolean

    /**
     * Set the limit on the number of destinations returned. The default is 20.
     * @type {number}
     * @memberof PublicApiListDestinations0
     */
    readonly limit?: number

    /**
     * Set the offset to start at when returning destinations. The default is 0
     * @type {number}
     * @memberof PublicApiListDestinations0
     */
    readonly offset?: number
}

/**
 * Request parameters for listJobs operation in PublicApi.
 * @export
 * @interface PublicApiListJobs0Request
 */
export interface PublicApiListJobs0Request {
    /**
     * Filter the Jobs by connectionId.
     * @type {string}
     * @memberof PublicApiListJobs0
     */
    readonly connectionId?: string

    /**
     * Set the limit on the number of Jobs returned. The default is 20 Jobs.
     * @type {number}
     * @memberof PublicApiListJobs0
     */
    readonly limit?: number

    /**
     * Set the offset to start at when returning Jobs. The default is 0.
     * @type {number}
     * @memberof PublicApiListJobs0
     */
    readonly offset?: number

    /**
     * Filter the Jobs by jobType.
     * @type {JobTypeEnum}
     * @memberof PublicApiListJobs0
     */
    readonly jobType?: JobTypeEnum

    /**
     * The UUIDs of the workspaces you wish to list jobs for. Empty list will retrieve all allowed workspaces.
     * @type {Array<string>}
     * @memberof PublicApiListJobs0
     */
    readonly workspaceIds?: Array<string>

    /**
     * The Job status you want to filter by
     * @type {JobStatusEnum}
     * @memberof PublicApiListJobs0
     */
    readonly status?: JobStatusEnum

    /**
     * The start date to filter by
     * @type {string}
     * @memberof PublicApiListJobs0
     */
    readonly createdAtStart?: string

    /**
     * The end date to filter by
     * @type {string}
     * @memberof PublicApiListJobs0
     */
    readonly createdAtEnd?: string

    /**
     * The start date to filter by
     * @type {string}
     * @memberof PublicApiListJobs0
     */
    readonly updatedAtStart?: string

    /**
     * The end date to filter by
     * @type {string}
     * @memberof PublicApiListJobs0
     */
    readonly updatedAtEnd?: string

    /**
     * The field and method to use for ordering
     * @type {string}
     * @memberof PublicApiListJobs0
     */
    readonly orderBy?: string
}

/**
 * Request parameters for listPermissions operation in PublicApi.
 * @export
 * @interface PublicApiListPermissions0Request
 */
export interface PublicApiListPermissions0Request {
    /**
     * User Id in permission.
     * @type {string}
     * @memberof PublicApiListPermissions0
     */
    readonly userId?: string

    /**
     * This is required if you want to read someone else\&#39;s permissions, and you should have organization admin or a higher role.
     * @type {string}
     * @memberof PublicApiListPermissions0
     */
    readonly organizationId?: string
}

/**
 * Request parameters for listSources operation in PublicApi.
 * @export
 * @interface PublicApiListSources0Request
 */
export interface PublicApiListSources0Request {
    /**
     * The UUIDs of the workspaces you wish to list sources for. Empty list will retrieve all allowed workspaces.
     * @type {Array<string>}
     * @memberof PublicApiListSources0
     */
    readonly workspaceIds?: Array<string>

    /**
     * Include deleted sources in the returned results.
     * @type {boolean}
     * @memberof PublicApiListSources0
     */
    readonly includeDeleted?: boolean

    /**
     * Set the limit on the number of sources returned. The default is 20.
     * @type {number}
     * @memberof PublicApiListSources0
     */
    readonly limit?: number

    /**
     * Set the offset to start at when returning sources. The default is 0
     * @type {number}
     * @memberof PublicApiListSources0
     */
    readonly offset?: number
}

/**
 * Request parameters for listUsersWithinAnOrganization operation in PublicApi.
 * @export
 * @interface PublicApiListUsersWithinAnOrganization0Request
 */
export interface PublicApiListUsersWithinAnOrganization0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiListUsersWithinAnOrganization0
     */
    readonly organizationId: string

    /**
     * List of user IDs to filter by
     * @type {Array<string>}
     * @memberof PublicApiListUsersWithinAnOrganization0
     */
    readonly ids?: Array<string>

    /**
     * List of user emails to filter by
     * @type {Array<string>}
     * @memberof PublicApiListUsersWithinAnOrganization0
     */
    readonly emails?: Array<string>
}

/**
 * Request parameters for listWorkspaces operation in PublicApi.
 * @export
 * @interface PublicApiListWorkspaces0Request
 */
export interface PublicApiListWorkspaces0Request {
    /**
     * The UUIDs of the workspaces you wish to fetch. Empty list will retrieve all allowed workspaces.
     * @type {Array<string>}
     * @memberof PublicApiListWorkspaces0
     */
    readonly workspaceIds?: Array<string>

    /**
     * Include deleted workspaces in the returned results.
     * @type {boolean}
     * @memberof PublicApiListWorkspaces0
     */
    readonly includeDeleted?: boolean

    /**
     * Set the limit on the number of workspaces returned. The default is 20.
     * @type {number}
     * @memberof PublicApiListWorkspaces0
     */
    readonly limit?: number

    /**
     * Set the offset to start at when returning workspaces. The default is 0
     * @type {number}
     * @memberof PublicApiListWorkspaces0
     */
    readonly offset?: number
}

/**
 * Request parameters for patchConnection operation in PublicApi.
 * @export
 * @interface PublicApiPatchConnection0Request
 */
export interface PublicApiPatchConnection0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiPatchConnection0
     */
    readonly connectionId: string

    /**
     * 
     * @type {ConnectionPatchRequest}
     * @memberof PublicApiPatchConnection0
     */
    readonly connectionPatchRequest: ConnectionPatchRequest
}

/**
 * Request parameters for patchDestination operation in PublicApi.
 * @export
 * @interface PublicApiPatchDestination0Request
 */
export interface PublicApiPatchDestination0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiPatchDestination0
     */
    readonly destinationId: string

    /**
     * 
     * @type {DestinationPatchRequest}
     * @memberof PublicApiPatchDestination0
     */
    readonly destinationPatchRequest?: DestinationPatchRequest
}

/**
 * Request parameters for patchSource operation in PublicApi.
 * @export
 * @interface PublicApiPatchSource0Request
 */
export interface PublicApiPatchSource0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiPatchSource0
     */
    readonly sourceId: string

    /**
     * 
     * @type {SourcePatchRequest}
     * @memberof PublicApiPatchSource0
     */
    readonly sourcePatchRequest?: SourcePatchRequest
}

/**
 * Request parameters for putDestination operation in PublicApi.
 * @export
 * @interface PublicApiPutDestination0Request
 */
export interface PublicApiPutDestination0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiPutDestination0
     */
    readonly destinationId: string

    /**
     * 
     * @type {DestinationPutRequest}
     * @memberof PublicApiPutDestination0
     */
    readonly destinationPutRequest?: DestinationPutRequest
}

/**
 * Request parameters for putSource operation in PublicApi.
 * @export
 * @interface PublicApiPutSource0Request
 */
export interface PublicApiPutSource0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiPutSource0
     */
    readonly sourceId: string

    /**
     * 
     * @type {SourcePutRequest}
     * @memberof PublicApiPutSource0
     */
    readonly sourcePutRequest?: SourcePutRequest
}

/**
 * Request parameters for updatePermission operation in PublicApi.
 * @export
 * @interface PublicApiUpdatePermission0Request
 */
export interface PublicApiUpdatePermission0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiUpdatePermission0
     */
    readonly permissionId: string

    /**
     * 
     * @type {PermissionUpdateRequest}
     * @memberof PublicApiUpdatePermission0
     */
    readonly permissionUpdateRequest: PermissionUpdateRequest
}

/**
 * Request parameters for updateWorkspace operation in PublicApi.
 * @export
 * @interface PublicApiUpdateWorkspace0Request
 */
export interface PublicApiUpdateWorkspace0Request {
    /**
     * 
     * @type {string}
     * @memberof PublicApiUpdateWorkspace0
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceUpdateRequest}
     * @memberof PublicApiUpdateWorkspace0
     */
    readonly workspaceUpdateRequest: WorkspaceUpdateRequest
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a running Job
     * @param {PublicApiCancelJob0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public cancelJob(requestParameters: PublicApiCancelJob0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).cancelJob(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a connection
     * @param {PublicApiCreateConnection0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createConnection(requestParameters: PublicApiCreateConnection0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).createConnection(requestParameters.connectionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a destination given a name, workspace id, and a json blob containing the configuration for the source.
     * @summary Create a destination
     * @param {PublicApiCreateDestination0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createDestination(requestParameters: PublicApiCreateDestination0Request = {}, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).createDestination(requestParameters.destinationCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a sync or reset job of a connection
     * @param {PublicApiCreateJob0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createJob(requestParameters: PublicApiCreateJob0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).createJob(requestParameters.jobCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create/update a set of OAuth credentials to override the Airbyte-provided OAuth credentials used for source/destination OAuth. In order to determine what the credential configuration needs to be, please see the connector specification of the relevant source/destination.
     * @summary Create OAuth override credentials for a workspace and source type.
     * @param {PublicApiCreateOrUpdateWorkspaceOAuthCredentials0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createOrUpdateWorkspaceOAuthCredentials(requestParameters: PublicApiCreateOrUpdateWorkspaceOAuthCredentials0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).createOrUpdateWorkspaceOAuthCredentials(requestParameters.workspaceId, requestParameters.workspaceOAuthCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a permission
     * @param {PublicApiCreatePermission0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createPermission(requestParameters: PublicApiCreatePermission0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).createPermission(requestParameters.permissionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
     * @summary Create a source
     * @param {PublicApiCreateSource0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createSource(requestParameters: PublicApiCreateSource0Request = {}, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).createSource(requestParameters.sourceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a workspace
     * @param {PublicApiCreateWorkspace0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createWorkspace(requestParameters: PublicApiCreateWorkspace0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).createWorkspace(requestParameters.workspaceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Connection
     * @param {PublicApiDeleteConnection0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteConnection(requestParameters: PublicApiDeleteConnection0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteConnection(requestParameters.connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Destination
     * @param {PublicApiDeleteDestination0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteDestination(requestParameters: PublicApiDeleteDestination0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteDestination(requestParameters.destinationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Permission
     * @param {PublicApiDeletePermission0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deletePermission(requestParameters: PublicApiDeletePermission0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).deletePermission(requestParameters.permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Source
     * @param {PublicApiDeleteSource0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteSource(requestParameters: PublicApiDeleteSource0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteSource(requestParameters.sourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Workspace
     * @param {PublicApiDeleteWorkspace0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteWorkspace(requestParameters: PublicApiDeleteWorkspace0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Connection details
     * @param {PublicApiGetConnection0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getConnection(requestParameters: PublicApiGetConnection0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).getConnection(requestParameters.connectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Destination details
     * @param {PublicApiGetDestination0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getDestination(requestParameters: PublicApiGetDestination0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).getDestination(requestParameters.destinationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getHealthCheck(options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).getHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Job status and details
     * @param {PublicApiGetJob0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getJob(requestParameters: PublicApiGetJob0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).getJob(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Permission details
     * @param {PublicApiGetPermission0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getPermission(requestParameters: PublicApiGetPermission0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPermission(requestParameters.permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Source details
     * @param {PublicApiGetSource0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSource(requestParameters: PublicApiGetSource0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSource(requestParameters.sourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get stream properties
     * @param {PublicApiGetStreamProperties0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getStreamProperties(requestParameters: PublicApiGetStreamProperties0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).getStreamProperties(requestParameters.sourceId, requestParameters.destinationId, requestParameters.ignoreCache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Workspace details
     * @param {PublicApiGetWorkspace0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getWorkspace(requestParameters: PublicApiGetWorkspace0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).getWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.  This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.  That secret ID can be used to create a source with credentials in place of actual tokens.
     * @summary Initiate OAuth for a source
     * @param {PublicApiInitiateOAuth0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public initiateOAuth(requestParameters: PublicApiInitiateOAuth0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).initiateOAuth(requestParameters.initiateOauthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List connections
     * @param {PublicApiListConnections0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listConnections(requestParameters: PublicApiListConnections0Request = {}, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).listConnections(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List destinations
     * @param {PublicApiListDestinations0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listDestinations(requestParameters: PublicApiListDestinations0Request = {}, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).listDestinations(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Jobs by sync type
     * @param {PublicApiListJobs0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listJobs(requestParameters: PublicApiListJobs0Request = {}, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).listJobs(requestParameters.connectionId, requestParameters.limit, requestParameters.offset, requestParameters.jobType, requestParameters.workspaceIds, requestParameters.status, requestParameters.createdAtStart, requestParameters.createdAtEnd, requestParameters.updatedAtStart, requestParameters.updatedAtEnd, requestParameters.orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists users organizations.
     * @summary List all organizations for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listOrganizationsForUser(options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).listOrganizationsForUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Permissions by user id
     * @param {PublicApiListPermissions0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPermissions(requestParameters: PublicApiListPermissions0Request = {}, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPermissions(requestParameters.userId, requestParameters.organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List sources
     * @param {PublicApiListSources0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listSources(requestParameters: PublicApiListSources0Request = {}, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).listSources(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Organization Admin user can list all users within the same organization. Also provide filtering on a list of user IDs or/and a list of user emails.
     * @summary List all users within an organization
     * @param {PublicApiListUsersWithinAnOrganization0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listUsersWithinAnOrganization(requestParameters: PublicApiListUsersWithinAnOrganization0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).listUsersWithinAnOrganization(requestParameters.organizationId, requestParameters.ids, requestParameters.emails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List workspaces
     * @param {PublicApiListWorkspaces0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listWorkspaces(requestParameters: PublicApiListWorkspaces0Request = {}, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).listWorkspaces(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Connection details
     * @param {PublicApiPatchConnection0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public patchConnection(requestParameters: PublicApiPatchConnection0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).patchConnection(requestParameters.connectionId, requestParameters.connectionPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Destination
     * @param {PublicApiPatchDestination0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public patchDestination(requestParameters: PublicApiPatchDestination0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).patchDestination(requestParameters.destinationId, requestParameters.destinationPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Source
     * @param {PublicApiPatchSource0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public patchSource(requestParameters: PublicApiPatchSource0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).patchSource(requestParameters.sourceId, requestParameters.sourcePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Destination and fully overwrite it
     * @param {PublicApiPutDestination0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public putDestination(requestParameters: PublicApiPutDestination0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).putDestination(requestParameters.destinationId, requestParameters.destinationPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Source and fully overwrite it
     * @param {PublicApiPutSource0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public putSource(requestParameters: PublicApiPutSource0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).putSource(requestParameters.sourceId, requestParameters.sourcePutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a permission
     * @param {PublicApiUpdatePermission0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updatePermission(requestParameters: PublicApiUpdatePermission0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).updatePermission(requestParameters.permissionId, requestParameters.permissionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace
     * @param {PublicApiUpdateWorkspace0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateWorkspace(requestParameters: PublicApiUpdateWorkspace0Request, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateWorkspace(requestParameters.workspaceId, requestParameters.workspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

