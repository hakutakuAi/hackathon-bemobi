/* tslint:disable */
/* eslint-disable */
/**
 * airbyte-api
 * Programatically control Airbyte Cloud, OSS & Enterprise.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { InitiateOauthRequest } from '../model';
// @ts-ignore
import type { SourceCreateRequest } from '../model';
// @ts-ignore
import type { SourcePatchRequest } from '../model';
// @ts-ignore
import type { SourcePutRequest } from '../model';
// @ts-ignore
import type { SourceResponse } from '../model';
// @ts-ignore
import type { SourcesResponse } from '../model';
/**
 * PublicSourcesApi - axios parameter creator
 * @export
 */
export const PublicSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
         * @summary Create a source
         * @param {SourceCreateRequest} [sourceCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (sourceCreateRequest?: SourceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Source
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (sourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSource', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Source details
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (sourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSource', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.  This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.  That secret ID can be used to create a source with credentials in place of actual tokens.
         * @summary Initiate OAuth for a source
         * @param {InitiateOauthRequest} initiateOauthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateOAuth: async (initiateOauthRequest: InitiateOauthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiateOauthRequest' is not null or undefined
            assertParamExists('initiateOAuth', 'initiateOauthRequest', initiateOauthRequest)
            const localVarPath = `/sources/initiateOAuth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateOauthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List sources
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list sources for. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted sources in the returned results.
         * @param {number} [limit] Set the limit on the number of sources returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning sources. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceIds) {
                localVarQueryParameter['workspaceIds'] = workspaceIds;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['includeDeleted'] = includeDeleted;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Source
         * @param {string} sourceId 
         * @param {SourcePatchRequest} [sourcePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSource: async (sourceId: string, sourcePatchRequest?: SourcePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchSource', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourcePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Source and fully overwrite it
         * @param {string} sourceId 
         * @param {SourcePutRequest} [sourcePutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSource: async (sourceId: string, sourcePutRequest?: SourcePutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('putSource', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication clientCredentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "clientCredentials", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourcePutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicSourcesApi - functional programming interface
 * @export
 */
export const PublicSourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicSourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
         * @summary Create a source
         * @param {SourceCreateRequest} [sourceCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(sourceCreateRequest?: SourceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(sourceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicSourcesApi.createSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Source
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(sourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicSourcesApi.deleteSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Source details
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(sourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicSourcesApi.getSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.  This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.  That secret ID can be used to create a source with credentials in place of actual tokens.
         * @summary Initiate OAuth for a source
         * @param {InitiateOauthRequest} initiateOauthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateOAuth(initiateOauthRequest: InitiateOauthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateOAuth(initiateOauthRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicSourcesApi.initiateOAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List sources
         * @param {Array<string>} [workspaceIds] The UUIDs of the workspaces you wish to list sources for. Empty list will retrieve all allowed workspaces.
         * @param {boolean} [includeDeleted] Include deleted sources in the returned results.
         * @param {number} [limit] Set the limit on the number of sources returned. The default is 20.
         * @param {number} [offset] Set the offset to start at when returning sources. The default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(workspaceIds?: Array<string>, includeDeleted?: boolean, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourcesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSources(workspaceIds, includeDeleted, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicSourcesApi.listSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Source
         * @param {string} sourceId 
         * @param {SourcePatchRequest} [sourcePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchSource(sourceId: string, sourcePatchRequest?: SourcePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSource(sourceId, sourcePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicSourcesApi.patchSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Source and fully overwrite it
         * @param {string} sourceId 
         * @param {SourcePutRequest} [sourcePutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSource(sourceId: string, sourcePutRequest?: SourcePutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSource(sourceId, sourcePutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicSourcesApi.putSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicSourcesApi - factory interface
 * @export
 */
export const PublicSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicSourcesApiFp(configuration)
    return {
        /**
         * Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
         * @summary Create a source
         * @param {PublicSourcesApiCreateSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(requestParameters: PublicSourcesApiCreateSourceRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SourceResponse> {
            return localVarFp.createSource(requestParameters.sourceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Source
         * @param {PublicSourcesApiDeleteSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(requestParameters: PublicSourcesApiDeleteSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSource(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Source details
         * @param {PublicSourcesApiGetSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(requestParameters: PublicSourcesApiGetSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<SourceResponse> {
            return localVarFp.getSource(requestParameters.sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.  This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.  That secret ID can be used to create a source with credentials in place of actual tokens.
         * @summary Initiate OAuth for a source
         * @param {PublicSourcesApiInitiateOAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateOAuth(requestParameters: PublicSourcesApiInitiateOAuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.initiateOAuth(requestParameters.initiateOauthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List sources
         * @param {PublicSourcesApiListSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(requestParameters: PublicSourcesApiListSourcesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SourcesResponse> {
            return localVarFp.listSources(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Source
         * @param {PublicSourcesApiPatchSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSource(requestParameters: PublicSourcesApiPatchSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<SourceResponse> {
            return localVarFp.patchSource(requestParameters.sourceId, requestParameters.sourcePatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Source and fully overwrite it
         * @param {PublicSourcesApiPutSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSource(requestParameters: PublicSourcesApiPutSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<SourceResponse> {
            return localVarFp.putSource(requestParameters.sourceId, requestParameters.sourcePutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSource operation in PublicSourcesApi.
 * @export
 * @interface PublicSourcesApiCreateSourceRequest
 */
export interface PublicSourcesApiCreateSourceRequest {
    /**
     * 
     * @type {SourceCreateRequest}
     * @memberof PublicSourcesApiCreateSource
     */
    readonly sourceCreateRequest?: SourceCreateRequest
}

/**
 * Request parameters for deleteSource operation in PublicSourcesApi.
 * @export
 * @interface PublicSourcesApiDeleteSourceRequest
 */
export interface PublicSourcesApiDeleteSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicSourcesApiDeleteSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for getSource operation in PublicSourcesApi.
 * @export
 * @interface PublicSourcesApiGetSourceRequest
 */
export interface PublicSourcesApiGetSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicSourcesApiGetSource
     */
    readonly sourceId: string
}

/**
 * Request parameters for initiateOAuth operation in PublicSourcesApi.
 * @export
 * @interface PublicSourcesApiInitiateOAuthRequest
 */
export interface PublicSourcesApiInitiateOAuthRequest {
    /**
     * 
     * @type {InitiateOauthRequest}
     * @memberof PublicSourcesApiInitiateOAuth
     */
    readonly initiateOauthRequest: InitiateOauthRequest
}

/**
 * Request parameters for listSources operation in PublicSourcesApi.
 * @export
 * @interface PublicSourcesApiListSourcesRequest
 */
export interface PublicSourcesApiListSourcesRequest {
    /**
     * The UUIDs of the workspaces you wish to list sources for. Empty list will retrieve all allowed workspaces.
     * @type {Array<string>}
     * @memberof PublicSourcesApiListSources
     */
    readonly workspaceIds?: Array<string>

    /**
     * Include deleted sources in the returned results.
     * @type {boolean}
     * @memberof PublicSourcesApiListSources
     */
    readonly includeDeleted?: boolean

    /**
     * Set the limit on the number of sources returned. The default is 20.
     * @type {number}
     * @memberof PublicSourcesApiListSources
     */
    readonly limit?: number

    /**
     * Set the offset to start at when returning sources. The default is 0
     * @type {number}
     * @memberof PublicSourcesApiListSources
     */
    readonly offset?: number
}

/**
 * Request parameters for patchSource operation in PublicSourcesApi.
 * @export
 * @interface PublicSourcesApiPatchSourceRequest
 */
export interface PublicSourcesApiPatchSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicSourcesApiPatchSource
     */
    readonly sourceId: string

    /**
     * 
     * @type {SourcePatchRequest}
     * @memberof PublicSourcesApiPatchSource
     */
    readonly sourcePatchRequest?: SourcePatchRequest
}

/**
 * Request parameters for putSource operation in PublicSourcesApi.
 * @export
 * @interface PublicSourcesApiPutSourceRequest
 */
export interface PublicSourcesApiPutSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicSourcesApiPutSource
     */
    readonly sourceId: string

    /**
     * 
     * @type {SourcePutRequest}
     * @memberof PublicSourcesApiPutSource
     */
    readonly sourcePutRequest?: SourcePutRequest
}

/**
 * PublicSourcesApi - object-oriented interface
 * @export
 * @class PublicSourcesApi
 * @extends {BaseAPI}
 */
export class PublicSourcesApi extends BaseAPI {
    /**
     * Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
     * @summary Create a source
     * @param {PublicSourcesApiCreateSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicSourcesApi
     */
    public createSource(requestParameters: PublicSourcesApiCreateSourceRequest = {}, options?: RawAxiosRequestConfig) {
        return PublicSourcesApiFp(this.configuration).createSource(requestParameters.sourceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Source
     * @param {PublicSourcesApiDeleteSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicSourcesApi
     */
    public deleteSource(requestParameters: PublicSourcesApiDeleteSourceRequest, options?: RawAxiosRequestConfig) {
        return PublicSourcesApiFp(this.configuration).deleteSource(requestParameters.sourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Source details
     * @param {PublicSourcesApiGetSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicSourcesApi
     */
    public getSource(requestParameters: PublicSourcesApiGetSourceRequest, options?: RawAxiosRequestConfig) {
        return PublicSourcesApiFp(this.configuration).getSource(requestParameters.sourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.  This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.  That secret ID can be used to create a source with credentials in place of actual tokens.
     * @summary Initiate OAuth for a source
     * @param {PublicSourcesApiInitiateOAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicSourcesApi
     */
    public initiateOAuth(requestParameters: PublicSourcesApiInitiateOAuthRequest, options?: RawAxiosRequestConfig) {
        return PublicSourcesApiFp(this.configuration).initiateOAuth(requestParameters.initiateOauthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List sources
     * @param {PublicSourcesApiListSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicSourcesApi
     */
    public listSources(requestParameters: PublicSourcesApiListSourcesRequest = {}, options?: RawAxiosRequestConfig) {
        return PublicSourcesApiFp(this.configuration).listSources(requestParameters.workspaceIds, requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Source
     * @param {PublicSourcesApiPatchSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicSourcesApi
     */
    public patchSource(requestParameters: PublicSourcesApiPatchSourceRequest, options?: RawAxiosRequestConfig) {
        return PublicSourcesApiFp(this.configuration).patchSource(requestParameters.sourceId, requestParameters.sourcePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Source and fully overwrite it
     * @param {PublicSourcesApiPutSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicSourcesApi
     */
    public putSource(requestParameters: PublicSourcesApiPutSourceRequest, options?: RawAxiosRequestConfig) {
        return PublicSourcesApiFp(this.configuration).putSource(requestParameters.sourceId, requestParameters.sourcePutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

